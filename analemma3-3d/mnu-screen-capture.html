<!doctype html>
<html lang = "en" >
<head>
<meta charset = "utf-8" >
<title></title>
<style>

	body { font: 12pt monospace; margin: 0; padding: 0 10px 0 0; }

	input[type=range] { -webkit-appearance: none; -moz-appearance: none; background-color: #ddd; width: 100%;}
	input[type=range]::-moz-range-thumb { background-color: #888; border-radius: 0; width: 10px; }
	input[type=range]::-webkit-slider-thumb { -webkit-appearance: none; background-color: #888; height: 20px; width: 10px; }

</style>
</head>
<body>
<script src=https://rawgit.com/spite/ccapture.js/dev/build/CCapture.all.min.js ></script>

  Screen Capture


	<p><input type=file id=inpFile onchange=openFile(this); ></p>
	
	<p id=menuOpenFile ></p>

	<p><button onclick=updateScene(); >update scene</button></p>

	<p><button onclick=capturer.start(); >capture start</button></p>

  <p><button onclick="capturer.stop();step=-1;" >capture stop</button></p>

	<p><button onclick=capturer.save(); >capture save</button></p>
	
<script>


//	var capturer = new CCapture( { format: 'webm' } );

// Create a capturer that exports an animated GIF
// Notices you have to specify the path to the gif.worker.js
	var capturer = new CCapture( { format: 'gif', workersPath: 'js/' } );

// Create a capturer that exports PNG images in a TAR file
//	var capturer = new CCapture( { format: 'png' } );

	// Create a capturer that exports JPEG images in a TAR file
//	var capturer = new CCapture( { format: 'jpg' } );

	var step = 0;
	var icw;
	var radius;



	init()


	function init() {




	}



	capturer = new CCapture( {
			verbose: true,
			display: true,
			name: 'demo',
			framerate: 20, //framerate
//			motionBlurFrames: ( 960 / framerate ) * ( document.querySelector('input[name="motion-blur"]').checked ? 1 : 0 ),
			quality: 80,
			format: 'gif', //document.querySelector('input[name="encoder"]:checked').value,
			workersPath: './js/',
//			timeLimit: 2,  // number of seconds to capture
			frameLimit: 240,
			autoSaveTime: 0,
//			onProgress: function( p ) { progress.style.width = ( p * 100 ) + '%' }
		} );

	}


	function openFile( files ) {

		var fileData, reader, data;

		reader = new FileReader();
		reader.onload = function( event ) {

			ifr.srcdoc = reader.result;

			menuOpenFile.innerHTML =
				'name: ' + files.files[0].name + '<br>' +
				'size: ' + files.files[0].size.toLocaleString() + ' bytes<br>' +
				'type: ' + files.files[0].type + '<br>' +
				'modified: ' + files.files[0].lastModifiedDate.toLocaleDateString() +
			'';

		}

		reader.readAsText( files.files[ 0 ] );

	}
	
	

	var animate = function () {

		icw.requestAnimationFrame( animate );
		icw.controls.update();
//		icw.stats.update();
		icw.renderer.render( icw.scene, icw.camera );

		if ( step >= 0 ) {

			step += Math.PI / 120;
			icw.camera.position.x = radius * Math.cos( step );
			icw.camera.position.y = 50
			icw.camera.position.z = radius * Math.sin( step );

			capturer.capture( icw.renderer.domElement );

		}
		
	}



	function updateScene() {

		icw = ifr.contentWindow;
		icw.controls.autoRotate = false;
		icw.renderer.setClearColor( 0xf0f0f0 );

		radius = icw.camera.position.distanceTo( new icw.THREE.Vector3( 0, icw.camera.position.y, 0 ) );
		step = 0;
		icw.animate = animate;

	}



	function endTheAction() {

		step = -1;

	}


</script>
</body>
</html>